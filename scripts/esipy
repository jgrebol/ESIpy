#!/usr/bin/env python3
from esipy.input import ESIInput
from esipy.readfchk import readfchk
from esipy import ESI
import sys
import os


def main():
    if len(sys.argv) < 2:
        print("Usage: input2esi <inputfile>")
        sys.exit(1)
    inputfile = sys.argv[1]
    print(" | Reading input file:", inputfile)
    inp = ESIInput.from_file(inputfile)

    mol = None
    mf = None
    molname = None  # molecule/calculation name for subdirectory

    if inp.mode == 'fchk':
        if not inp.fchk_file:
            print("No fchk file specified in input.")
            sys.exit(1)
        if not os.path.isfile(inp.fchk_file):
            print(f"Error: The file '{inp.fchk_file}' does not exist.")
            sys.exit(1)
        mol, mf = readfchk(inp.fchk_file)
        # Get the name of the molecule without the extension
        molname = os.path.splitext(os.path.basename(inp.fchk_file))[0]

    elif inp.mode == 'readint':
        # Read .int files from a directory
        if not inp.readpath:
            print("No directory specified for $READINT.")
            sys.exit(1)
        mol, mf = None, None
        # The name is the directory name
        molname = inp.readpath

    elif inp.mode == 'readaoms':
        # Name of the calculation to read the .aoms and .molinfo files
        if not inp.aomname:
            print("No AOM base name specified for $READAOMS.")
            sys.exit(1)
        molname = inp.aomname
        mol, mf = None, None

    else:
        print(f"Unknown input mode: {inp.mode}")
        sys.exit(1)

    # Convert FLUREF to dicts if needed
    flurefs = None
    if inp.fluref:
        flurefs = {f"REF{i+1}": v for i, v in enumerate(inp.fluref)}
    # Partition
    partitions = inp.partition if inp.partition else ['meta_lowdin']

    # MCI handling: pass explicit mci kw only if user selected True/False
    if inp.mci is True:
        mci_kwargs = {'mci': True}
    elif inp.mci is False:
        mci_kwargs = {'mci': False}
    else:
        mci_kwargs = {}

    # Forward ncores if provided
    extra_kwargs = {}
    if inp.ncores is not None:
        extra_kwargs['ncores'] = inp.ncores

    # AV1245: True if requested, otherwise None (do not pass the kw => let ESI decide)
    av1245 = True if inp.av1245 else None

    # AV1245 used as keyword if set
    # If it's True (boolean not converted), use molname. If it's a string, use that. Otherwise None.
    if inp.save is True:
        save_name = molname
    elif inp.save:
        save_name = inp.save
    else:
        save_name = None
    # Findrings
    findrings = inp.findrings
    # Minlen/Maxlen
    minlen = inp.minlen if inp.minlen else 6
    maxlen = inp.maxlen if inp.maxlen else 12
    # Rings
    if findrings:
        rings = "find"
    elif inp.rings:
        rings = inp.rings
    elif inp.fragments:
        rings = inp.fragments.copy()
    else:
        rings = None
    # If fragments are present, replace matching atom indices in rings with sets
    if rings and inp.fragments:
        def replace_fragments(ring, fragments):
            result = []
            for atom in ring:
                found = False
                for frag in fragments:
                    if atom in frag:
                        result.append(frag)
                        found = True
                        break
                if not found:
                    result.append(atom)
            return result
        if isinstance(rings[0], list):
            rings = [replace_fragments(ring, inp.fragments) for ring in rings]
        else:
            rings = replace_fragments(rings, inp.fragments)

    # Construct ESI for each partition
    for partition in partitions:
        if inp.mode == 'readaoms':
            # Construct aom and molinfo filenames with partition name
            aom = inp.aomname + '_' + partition + '.aoms'
            molinfo = inp.aomname + '_' + partition + '.molinfo'
            # pass aom and molinfo strings so ESI will load them
            esi = ESI(aom=aom, rings=rings, partition=partition, molinfo=molinfo,
                      av1245=av1245, save=save_name, minlen=minlen, maxlen=maxlen, **mci_kwargs, **extra_kwargs)
        elif inp.mode == 'readint':
            # Construct the directory path with SHORT partition name: name_shortpart_atomicfiles
            from esipy.tools import format_short_partition
            shortpart = format_short_partition(partition)
            if partition == "qtaim": # From AIMAll it is the name and the _atomicfiles. For ESIpy we include the partition
                partition_dir = inp.readpath + '_atomicfiles'
            else:
                partition_dir = inp.readpath + '_' + shortpart + '_atomicfiles'
            # tell ESI to read from the partition-specific directory
            esi = ESI(read=True, readpath=partition_dir, rings=rings, partition=partition,
                      av1245=av1245, save=save_name, minlen=minlen, maxlen=maxlen, **mci_kwargs, **extra_kwargs)
            # Read the AOMs now
            esi.readaoms()
        else:  # fchk
            esi = ESI(mol=mol, mf=mf, rings=rings, partition=partition, flurefs=flurefs, homarefs=homarefs,
                      av1245=av1245, save=save_name, minlen=minlen, maxlen=maxlen, **mci_kwargs, **extra_kwargs)
        esi.print()

        # MCI Approximations, in format (alg, d)
        if inp.mciaprox:
            for alg, d in inp.mciaprox:
                esi.mciaprox(mcialg=alg, d=d)

        # Write AOMs if $WRITEAOMS keyword is present
        # Use save_name if available (from $SAVE), otherwise use molname
        if inp.writeaoms:
            write_name = save_name if save_name else molname
            if write_name:
                esi.writeaoms(write_name)

if __name__ == "__main__":
    main()
